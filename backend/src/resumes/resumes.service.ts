import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../database/prisma.service';
import { CreateResumeDto } from './dto/create-resume.dto';
import { UpdateResumeDto } from './dto/update-resume.dto';

/**
 * Resumes Service
 * Handles resume CRUD operations and auto-generation from achievements
 */
@Injectable()
export class ResumesService {
  constructor(private prisma: PrismaService) {}

  /**
   * Create a new resume for user
   */
  async create(userId: string, createResumeDto: CreateResumeDto) {
    // Check if user already has a resume
    const existingResume = await this.prisma.resume.findUnique({
      where: { userId },
    });

    if (existingResume) {
      // Update existing resume instead
      return this.update(userId, createResumeDto);
    }

    // Create new resume
    const resume = await this.prisma.resume.create({
      data: {
        userId,
        title: createResumeDto.title || 'Professional Resume',
        summary: createResumeDto.summary,
        objective: createResumeDto.objective,
        templateStyle: createResumeDto.templateStyle || 'modern',
        isPublic: createResumeDto.isPublic || false,
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Auto-populate resume with user's achievements
    await this.autoUpdateResumeFromAchievements(userId);

    return this.findOne(userId);
  }

  /**
   * Get user's resume
   */
  async findOne(userId: string) {
    const resume = await this.prisma.resume.findUnique({
      where: { userId },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            phone: true,
            profileImage: true,
            achievements: {
              orderBy: { startDate: 'desc' },
            },
            skills: {
              orderBy: { proficiency: 'desc' },
            },
          },
        },
      },
    });

    if (!resume) {
      throw new NotFoundException('Resume not found');
    }

    return resume;
  }

  /**
   * Update resume
   */
  async update(userId: string, updateResumeDto: UpdateResumeDto) {
    // Verify resume exists
    await this.findOne(userId);

    const resume = await this.prisma.resume.update({
      where: { userId },
      data: {
        ...updateResumeDto,
        lastGeneratedAt: new Date(),
      },
    });

    return this.findOne(userId);
  }

  /**
   * Delete resume
   */
  async delete(userId: string) {
    await this.findOne(userId);

    await this.prisma.resume.delete({
      where: { userId },
    });

    return { message: 'Resume deleted successfully' };
  }

  /**
   * AUTO-UPDATE FUNCTIONALITY
   * Regenerate resume content from user's achievements
   * This is called automatically when achievements are added/updated
   */
  async autoUpdateResumeFromAchievements(userId: string) {
    // Get user with all achievements and skills
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        achievements: {
          orderBy: { startDate: 'desc' },
        },
        skills: {
          orderBy: { proficiency: 'desc' },
        },
        resume: true,
      },
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    // Generate experience section from achievements
    const experience = this.generateExperienceFromAchievements(user.achievements);

    // Generate education section
    const education = this.generateEducationFromAchievements(user.achievements);

    // Auto-generate summary based on achievements
    const autoGeneratedSummary = this.generateSummary(user);

    // Update or create resume
    if (user.resume) {
      await this.prisma.resume.update({
        where: { userId },
        data: {
          experience,
          education,
          summary: user.resume.summary || autoGeneratedSummary,
          lastGeneratedAt: new Date(),
        },
      });
    } else {
      await this.prisma.resume.create({
        data: {
          userId,
          experience,
          education,
          summary: autoGeneratedSummary,
          lastGeneratedAt: new Date(),
        },
      });
    }

    return this.findOne(userId);
  }

  /**
   * Generate work experience from achievements
   */
  private generateExperienceFromAchievements(achievements: any[]) {
    const internships = achievements.filter(
      (a) => a.type === 'INTERNSHIP' || a.type === 'VOLUNTEER',
    );

    return {
      positions: internships.map((internship) => ({
        title: internship.title,
        company: internship.organization,
        location: internship.location,
        startDate: internship.startDate,
        endDate: internship.endDate,
        duration: internship.duration,
        responsibilities: internship.highlights,
        skills: internship.skills,
        verified: internship.isVerified,
      })),
    };
  }

  /**
   * Generate education section from achievements
   */
  private generateEducationFromAchievements(achievements: any[]) {
    const courses = achievements.filter(
      (a) => a.type === 'COURSE' || a.type === 'CERTIFICATION',
    );

    return {
      degrees: courses.map((course) => ({
        degree: course.title,
        institution: course.organization,
        startDate: course.startDate,
        endDate: course.endDate,
        grade: course.grade,
        skills: course.skills,
        certificateUrl: course.certificateUrl,
        verified: course.isVerified,
      })),
    };
  }

  /**
   * Auto-generate professional summary
   */
  private generateSummary(user: any): string {
    const { achievements, skills } = user;
    const name = `${user.firstName} ${user.lastName}`;

    const internshipCount = achievements.filter((a) => a.type === 'INTERNSHIP').length;
    const courseCount = achievements.filter((a) => a.type === 'COURSE').length;
    const projectCount = achievements.filter((a) => a.type === 'PROJECT').length;
    const hackathonCount = achievements.filter((a) => a.type === 'HACKATHON').length;

    const topSkills = skills
      .slice(0, 5)
      .map((s) => s.name)
      .join(', ');

    let summary = `${name} is a dedicated professional with`;

    const experiences: string[] = [];
    if (internshipCount > 0) experiences.push(`${internshipCount} internship${internshipCount > 1 ? 's' : ''}`);
    if (projectCount > 0) experiences.push(`${projectCount} project${projectCount > 1 ? 's' : ''}`);
    if (hackathonCount > 0) experiences.push(`${hackathonCount} hackathon${hackathonCount > 1 ? 's' : ''}`);
    if (courseCount > 0) experiences.push(`${courseCount} certification${courseCount > 1 ? 's' : ''}`);

    if (experiences.length > 0) {
      summary += ` ${experiences.join(', ')} completed.`;
    } else {
      summary += ' a strong passion for learning and development.';
    }

    if (topSkills) {
      summary += ` Proficient in ${topSkills}.`;
    }

    summary += ' Eager to contribute to innovative projects and continue professional growth.';

    return summary;
  }

  /**
   * Export resume in different formats
   */
  async exportResume(userId: string, format: 'json' | 'pdf' = 'json') {
    const resume = await this.findOne(userId);

    if (format === 'json') {
      return {
        format: 'json',
        data: resume,
      };
    }

    // PDF generation would be implemented here
    // For now, return JSON structure
    return {
      format: 'pdf',
      message: 'PDF generation coming soon',
      data: resume,
    };
  }
}

